#!/usr/bin/env python3
"""
Script to generate DIRECTORY.md file for TheAlgorithms repositories.
This script walks through the repository and creates a markdown file
listing all algorithm implementations.

Usage:
    python3 build_directory_md.py <Language> <Base Path> <File Extensions> [Ignore Patterns] [Include Children]

Example:
    python3 build_directory_md.py Mojo . .mojo
"""

import os
import sys
from pathlib import Path


def good_filepaths(top_dir: str = ".", ext: str = ".mojo") -> list:
    """
    Get all valid file paths in the repository.
    
    Args:
        top_dir: Base directory to search
        ext: File extension to filter
    
    Returns:
        List of valid file paths
    """
    filepaths = []
    
    for dirpath, dirnames, filenames in os.walk(top_dir):
        # Skip hidden directories and common ignore patterns
        dirnames[:] = [
            d for d in dirnames
            if d[0] not in "._" 
            and d.lower() not in ["scripts", ".git", ".github", "venv", "__pycache__", "node_modules"]
        ]
        
        for filename in filenames:
            if filename.endswith(ext):
                filepath = os.path.join(dirpath, filename)
                filepaths.append(filepath)
    
    return sorted(filepaths)


def md_prefix(i: int) -> str:
    """Generate markdown list prefix based on depth."""
    return f"{'  ' * i}*" if i else "\n##"


def print_path(old_path: list, new_path: list) -> list:
    """
    Print the directory structure in markdown format.
    
    Args:
        old_path: Previous path components
        new_path: Current path components
    
    Returns:
        Updated path
    """
    for i, new_part in enumerate(new_path):
        if i + 1 > len(old_path) or old_path[i] != new_part:
            if new_part:
                print(f"{md_prefix(i)} {new_part.replace('_', ' ').title()}")
            for j in range(i + 1, len(new_path)):
                print(f"{md_prefix(j)} {new_path[j].replace('_', ' ').title()}")
            return new_path
    return old_path


def print_directory_contents(ext: str, top_dir: str = ".") -> None:
    """
    Print the directory contents in markdown format.
    
    Args:
        ext: File extension to filter
        top_dir: Base directory to search
    """
    old_path = []
    filepaths = good_filepaths(top_dir, ext)
    
    for filepath in filepaths:
        filepath = filepath.replace(os.sep, "/")
        parts = filepath.split("/")
        
        # Remove base directory if present
        if parts[0] == ".":
            parts = parts[1:]
        
        # Split into directory and filename
        directory = parts[:-1]
        filename = parts[-1]
        
        # Print directory structure
        old_path = print_path(old_path, directory)
        
        # Print filename with link
        indent = "  " * len(directory)
        name = filename.replace(ext, "").replace("_", " ").title()
        print(f"{indent}* [{name}]({filepath})")


def main() -> None:
    """Main function to generate DIRECTORY.md."""
    if len(sys.argv) < 4:
        print("Usage: python3 build_directory_md.py <Language> <Base Path> <File Extensions>")
        sys.exit(1)
    
    language = sys.argv[1]
    base_path = sys.argv[2]
    extensions = sys.argv[3]
    
    # Print header
    print(f"# List of all {language} files")
    print(f"\nThis file is automatically generated by the `directory_writer` workflow.")
    print(f"Do not edit this file directly.\n")
    
    # Process each extension
    for ext in extensions.split(","):
        ext = ext.strip()
        print_directory_contents(ext, base_path)


if __name__ == "__main__":
    main()
